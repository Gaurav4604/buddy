
            <text>
            The diagram has fewer transitions than the earlier DFA, so it appears simpler.

There are two transitions from state q0, labelled 0. Thus when a 0 is received, the NFA enters both state q0 and state q1. We will see how to think about this situation shortly.

There is no transition corresponding to 0 from state q1, and no transitions at all from state q2. If these situations occur, the thread of the NFA’s existence that corresponds to these states simply “dies”. Other threads may continue to exist.
            </text>
            

            <text>
            The central idea of this NFA is to try to "guess" when the final 01 has begun. Whenever it is in state q_0, and it sees a zero, it guesses that the 0 is the beginning of the final 01, so it enters state q_1. (If it guessed correctly, a subsequent 1 will cause it to enter state q_2.) However, just in case it makes a bad guess, and the 0 is _not_ the beginning of a 01 sequence, the NFA "hedges its best" and also remains in state q_0.


            </text>
            

            <title>
            
# 2.1.1   Example — the zeroOne NFA processing a string


    



    

            </title>
            

            <text>
            is works, let us process the same string 011001 that was handled by the previous DF
            </text>
            

        <image>
        <path>
        outputs/automata/images/chapter_1/page_1_4.jpg
        </path>
        <description>
        A sequence of three states in a finite state machine (FSM) with transitions between them. The FSM starts at q0, moves to q1 after an input 'a', and then to q2 after another input 'b'. Each transition is labeled by the number 0 or 1 representing different paths taken during execution.
        </description>
        </image>
        

            <text>
            # Initially, the NFA is in state q_0.


            </text>
            

            <text>
            After processing the input symbol 0, the NFA enters states go and q;. There are thus two dots showing the current state.
            </text>
            

            <text>
            To process the input symbol 1, we must handle two cases. The dot in go results in the next state being q0. The dot in q results in the next state being q0. There are two current states g0 and q2, and the diagram now looks like this:
            </text>
            

            <text>
            Since q_2 is an accepting state, the NFA has recognised a string that ends in 01. 
            </text>
            

        <image>
        <path>
        outputs/automata/images/chapter_1/page_1_9.jpg
        </path>
        <description>
        A state diagram with three states: q0, q1, and q2. The initial state is q0, which has two transitions labeled 0 and 1 leading to q1. From q1, there are two transitions labeled 0 and 1 leading to q2.
        </description>
        </image>
        

            <text>
            To process the input symbol 1, again we must handle two cases. The dot in q0 results in the next state being q0. q0 has no outgoing transitions, so there is no next state. There is only one current state, and the diagram is:
            </text>
            

        <image>
        <path>
        outputs/automata/images/chapter_1/page_1_11.jpg
        </path>
        <description>
        A state diagram with three states: q0, q1, and q2. The initial state is q0, which has two transitions to q1 based on input 0 or 1. From q1, there are two transitions to q2 based on inputs 0 or 1.
        </description>
        </image>
        
