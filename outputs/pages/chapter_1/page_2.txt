
            <text>
            * The diagram has fewer transitions than the earlier DFA, so it appears simpler.
* There are two transitions from state q0, labelled 0. Thus when a 0 is received, the NFA enters both state q0 and state q1. We will see how to think about this situation shortly.
* There is no transition corresponding to 0 from state q1, and no transitions at all from state q2. If these situations occur, the thread of the NFA’s existence that corresponds to these states simply “dies”. Other threads may continue to exist.
            </text>
            

            <text>
            The central idea of this NFA is to try to “guess” when the final 01 has begun. Whenever it is in state q_0, and it sees a zero, it guesses that the 0 is the beginning of the final 01, so it enters state q_1. (If it guessed correctly, a subsequent 1 will cause it to enter state q_2.) However, just in case it makes a bad guess, and the 0 is not the beginning of a 01 sequence, the NFA “hedges its bets” and also remains in state q_0.
            </text>
            

            <title>
            # 2.1.1 Example — the zeroOne NFA processing a string

2.1.1 Example — the zeroOne NFA processing a string
            </title>
            

            <text>
            is works, let us process the same string 011001 that was handled by the previous DR.

is works, let us process the same string 011001 that was handled by the previous DF
            </text>
            

        <image>
        <path>
        outputs/images/chapter_1/page_1_4.jpg
        </path>
        <description>
        diagrams showing different states and transitions in a finite state machine
        </description>
        </image>
        

            <text>
            # Initially, the NFA is in state q₀.


            </text>
            

            <text>
            After processing the input symbol 0, the NFA enters states q₀ and q₁. There are thus two dots showing the current state.
            </text>
            

            <text>
            To process the input symbol 1, we must handle two cases. The dot in q₀ results in the next state being q₀. The dot in q₁ results in the next state being q₂. There are two current states q₀ and q₂, and the diagram now looks like this:

To process the input symbol 1, we must
handle two cases. The dot in go results
in the next state being qo. The dot in q
results in the next state being qo. There
are two current states gg and q2, and the
diagram now looks like this:
            </text>
            

            <text>
            Since q₂ is an accepting state, the NFA has recognized a string that ends in 01.
            </text>
            

        <image>
        <path>
        outputs/images/chapter_1/page_1_9.jpg
        </path>
        <description>
        A state diagram with three states labeled q0, q1, and q2. The initial state is q0, which has two transitions: one to q1 on input 0, and another to itself on input 1. State q1 has a single transition from it to q2 on input 1. There are no other inputs or states in the diagram.
        </description>
        </image>
        

            <text>
            To process the input symbol 1, again we must handle two cases. The dot in q₀ results in the next state being q₀. q₂ has no outgoing transitions, so there is no next state. There is only one current state, and the diagram is:


    Case 1:   
    Case 2:

            </text>
            

        <image>
        <path>
        outputs/images/chapter_1/page_1_11.jpg
        </path>
        <description>
        A state diagram with three states: q0, q1, and q2. The initial state is q0, which has two transitions labeled 0 and 1 leading to q1. From q1, there are two transitions labeled 0 and 1 leading to q2.
        </description>
        </image>
        
