Here is the merged and converted LaTeX document:

\documentclass{article}

\begin{document}

\section{Event-Driven Systems}
Reactive or event-driven systems can cover a broad spectrum of applications. The most common are:
Graphical User Interfaces (GUIs) 
It is very difficult to write correct code for GUIs without using event-driven techniques. In this course, we will show you how to construct bug-free GUIs.

Embedded Systems If you are an engineer, you will almost certainly be involved in designing or implementing an embedded control system for a product. The reason is simple: a microcon-
troller is the cheapest and most flexible way to implement the control section of almost every
electronic product. Those of you who are studying the courses “Software Engineering and 
Project” or “Embedded Computer Systems” will find that knowledge of event-driven systems
will significantly simplify the software for your projects.

Communication Protocols Modern computer systems are extensively networked, to allow them
to exchange data. All computer communication depends on a protocol for the exchange of
data. Communication protocols need to be able to respond to events, such as: arrival of a
message, arrival of an acknowledgement, timeout after sending a message, and so on. All
these events can occur in any order. A protocol can only be implemented reliably using event-
driven programming techniques.

A “protocol stack” is a layered set of intercommunicating protocols that together permit
computer-to-computer communication. Each layer in the stack is a reactive program. A
protocol stack is thus, by its very nature, highly reactive, and highly concurrent.

Despite the variety of applications for event-driven systems, there are some well understood
techniques for designing and implementing these systems. They can significantly reduce the time,
effort and the likelihood of bugs when writing your code. They also will make your program much
easier to change in the future.

By making clear design and implementation decisions at the beginning, you will retain intellec-
tual control over the complexity inherent in all reactive systems.


\section{A Little History}

The ideas behind finite state machines have been around for a long time now. In the 1930s,
Alan Turing did research on computable functions, and invented the “Turing machine”, a simple
processor that has been proved to have the same capabilities as any current-day computer.

In the 1940s, McCulloch and Pitts modelled the behaviour of nerve networks, using ideas similar
to those presented in these notes.

In the mid 1950s, papers by Mealy and Moore, from the Engineering community, had a big
influence on the design of switching systems in telephone exchanges. Both described finite state
machines as we now know them. We will look at the nature of their work a little later on.

At the end of the 1950s, Rabin and Scott published a paper that introduced non-deteministic finite state machines, and provided fruitful insights for further work. They received the ACM Turing award for this work.


\section{An Introductory Example - The Tap-Light}

Let us consider a simple but familiar example: an electric table lamp that is controled by simply "tapping" it: when a user taps the lamp, it turns on; tap again, and it turns back off; tap again, and it turns back on; and so on. We can represent this behaviour in a state-diagram, as shown in \ref{fig:tap-light}.

\begin{figure}[ht]
\centering
\includegraphics[width=0.5\textwidth]{tap-light}
\caption{State diagram for the tap-light example}
\label{fig:tap-light}
\end{figure}

\end{document}